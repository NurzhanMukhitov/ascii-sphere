<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>3D ANIMATED SPHERE</title>
  <style>
    /* Сброс отступов и базовые стили */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background: black;
      color: white;
      font-family: monospace;
      overflow: hidden; /* убираем скролл */
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* Заголовок на всю ширину */
    header {
      text-align: center;
      font-size: 48px;
      margin-top: 20px;
      letter-spacing: 2px;
    }

    /* Блок слева */
    .left-info {
      position: absolute;
      top: 120px;
      left: 20px;
      font-size: 16px;
      line-height: 1.5;
      max-width: 300px;
    }
    /* Заголовок внутри .left-info (ЧТО ЭТО) */
    .left-info h2 {
      text-transform: uppercase;
      font-size: 24px;
      margin-bottom: 10px;
    }

    /* Canvas по центру */
    #canvas {
      display: block;
      margin: 0 auto;
    }

    /* Блок снизу слева */
    .bottom-links {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 16px;
      line-height: 1.5;
    }
    /* Заголовок внутри .bottom-links (СДЕЛАНО) */
    .bottom-links h2 {
      text-transform: uppercase;
      font-size: 24px;
      margin-bottom: 10px;
    }

    /* Стиль кнопки Instagram */
    .instagram-button {
      display: inline-block;
      margin-top: 8px;
      padding: 5px 10px;
      border: 1px solid white;
      color: white;
      text-decoration: none;
      transition: background 0.3s, color 0.3s;
    }
    .instagram-button:hover {
      background: white;
      color: black;
    }
  </style>
</head>
<body>
  <!-- Заголовок -->
  <header>3D ANIMATED SPHERE</header>

  <!-- Текст слева -->
  <div class="left-info">
    <h2>ЧТО ЭТО</h2>
    <p>
      Это псевдографическая симуляция, где каждый символ означает 3D-точку.
      Код написан Chat GPT. Симуляция интерактивная и с ней можно взаимодействовать.
    </p>
  </div>

  <!-- Canvas для ASCII-сферы -->
  <canvas id="canvas"></canvas>

  <!-- Блок снизу (СДЕЛАНО + Instagram) -->
  <div class="bottom-links">
    <h2>СДЕЛАНО</h2>
    <a class="instagram-button" href="https://www.instagram.com/nmk_one/" target="_blank">
      Instagram
    </a>
  </div>

  <script>
    /* Получаем canvas и контекст */
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    /* Устанавливаем размеры canvas */
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /* Параметры сферы */
    const numPoints = 1000;  // Количество точек
    const radius = 200;      // Радиус сферы
    const zOffset = 400;     // Смещение сферы по оси Z
    const points = [];

    /* Генерация точек на сфере */
    for (let i = 0; i < numPoints; i++) {
      const theta = Math.acos(2 * Math.random() - 1); // угол от 0 до π
      const phi = 2 * Math.PI * Math.random();        // угол от 0 до 2π
      const x = radius * Math.sin(theta) * Math.cos(phi);
      const y = radius * Math.sin(theta) * Math.sin(phi);
      const z = radius * Math.cos(theta) + zOffset;

      // Случайный символ (0-9)
      const char = Math.floor(Math.random() * 10);
      points.push({ x, y, z, char });
    }

    /* Углы вращения */
    let rotationX = 0;
    let rotationY = 0;
    let rotationZ = 0; // можно крутить для «хаотичности»

    /* Управление мышью */
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;

      // Поворот вокруг Y от dx
      rotationY += dx * 0.01;
      // Поворот вокруг X от dy
      rotationX += dy * 0.01;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });
    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    /* Поворот точки вокруг X, Y, Z */
    function rotate(point, angleX, angleY, angleZ) {
      let { x, y, z } = point;

      // Поворот вокруг X
      let cos = Math.cos(angleX), sin = Math.sin(angleX);
      let y1 = y * cos - z * sin;
      let z1 = y * sin + z * cos;
      y = y1;
      z = z1;

      // Поворот вокруг Y
      cos = Math.cos(angleY); sin = Math.sin(angleY);
      let x1 = x * cos + z * sin;
      let z2 = -x * sin + z * cos;
      x = x1;
      z = z2;

      // Поворот вокруг Z
      cos = Math.cos(angleZ); sin = Math.sin(angleZ);
      let x2 = x * cos - y * sin;
      let y2 = x * sin + y * cos;
      x = x2;
      y = y2;

      return { x, y, z, char: point.char };
    }

    /* Перспективная проекция */
    function project(point) {
      const focalLength = 500; // "камера"
      const scale = focalLength / (focalLength + point.z);
      return {
        x: point.x * scale + canvas.width / 2,
        y: point.y * scale + canvas.height / 2
      };
    }

    /* Анимация */
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let p of points) {
        const rotated = rotate(p, rotationX, rotationY, rotationZ);
        const proj = project(rotated);

        // Вычисляем яркость на основе z
        const brightnessFactor = 1 - ((rotated.z - (zOffset - radius)) / (2 * radius));
        const shade = Math.floor(128 + brightnessFactor * 127);

        ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
        ctx.font = "16px monospace";
        ctx.fillText(p.char, proj.x, proj.y);
      }

      // Автовращение — хаотичные приращения
      rotationX += 0.005;
      rotationY += 0.01;
      rotationZ += 0.003;

      requestAnimationFrame(draw);
    }
    draw();

    /* Ресайз */
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Cube of Lines - UNIVERSE DESIGN</title>
  <style>
    * {
      margin: 0; padding: 0; box-sizing: border-box;
    }
    body {
      width: 100vw; height: 100vh;
      background: black; color: white;
      overflow: hidden; position: relative;
      font-family: monospace;
    }
    canvas {
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Параметры
  const letters = "UNIVERSE DESIGN";  // строка букв
  const cubeSize = 200;              // размер куба (по x и y от -100 до +100, z от -100 до +100)
  const half = cubeSize / 2;         // 100
  const topZ = +half;                // +100 (верхняя грань)
  const botZ = -half;                // -100 (нижняя грань)
  const linesX = 20;                 // сколько линий в направлении X
  const linesY = 20;                 // сколько линий в направлении Y
  const pointsPerLine = 30;          // сколько точек на каждой нити
  const zOffset = 0;                 // смещение куба по оси Z (если нужно, можешь поставить +300)
  
  // Храним массив всех точек
  let points = [];
  // Параметр t: 0 = куб собран, 1 = полностью разбросан
  let tParam = 0;

  // 1) Генерируем «ниточки» (линии) вдоль оси Z
  //    То есть для каждой (x,y) на "верхней" грани -> линия к (x,y) на "нижней" грани
  //    Итого linesX × linesY линий

  // Функция для выбора случайной scatter-позиции
  function randomScatter() {
    // Разброс ±1000 (настрой по вкусу)
    return {
      x: (Math.random() - 0.5) * 2000,
      y: (Math.random() - 0.5) * 2000,
      z: (Math.random() - 0.5) * 2000
    };
  }

  // Функция для взятия буквы из letters (повтор циклически)
  let letterIndex = 0;
  function nextLetter() {
    const ch = letters[letterIndex % letters.length];
    letterIndex++;
    return ch;
  }

  // Генерация линий
  for (let i = 0; i < linesX; i++) {
    // x от -half до +half
    const fracX = i / (linesX - 1);
    const xVal = -half + fracX * cubeSize;

    for (let j = 0; j < linesY; j++) {
      // y от -half до +half
      const fracY = j / (linesY - 1);
      const yVal = -half + fracY * cubeSize;

      // Линия идёт от z=topZ до z=botZ
      for (let k = 0; k < pointsPerLine; k++) {
        const fracZ = k / (pointsPerLine - 1);
        // Позиция в «собранном» состоянии (куб)
        const zVal = topZ * (1 - fracZ) + botZ * fracZ;  // линейная интерполяция от topZ к botZ
        // Добавляем смещение zOffset
        const cubePos = { x: xVal, y: yVal, z: zVal + zOffset };
        // Позиция в «разбросанном» состоянии
        const scatterPos = randomScatter();
        // Буква
        const ch = nextLetter();
        // Сохраняем
        points.push({ cubePos, scatterPos, char: ch });
      }
    }
  }

  // 2) Функция проекции (простая перспектива)
  function project3D(x, y, z) {
    const focal = 500;    // фокальное расстояние (камера)
    const scale = focal / (focal + z);
    return {
      x: x * scale + canvas.width / 2,
      y: y * scale + canvas.height / 2
    };
  }

  // 3) Отрисовка
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let p of points) {
      // Интерполяция между cubePos и scatterPos
      const x = (1 - tParam) * p.cubePos.x + tParam * p.scatterPos.x;
      const y = (1 - tParam) * p.cubePos.y + tParam * p.scatterPos.y;
      const z = (1 - tParam) * p.cubePos.z + tParam * p.scatterPos.z;
      // Проекция
      const proj = project3D(x, y, z);
      // Яркость (зависит от z, можно менять логику)
      const brightnessFactor = 1 - ((z - botZ) / (2 * half));
      const shade = Math.floor(128 + brightnessFactor * 127);
      ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
      ctx.font = "14px monospace";
      ctx.fillText(p.char, proj.x, proj.y);
    }

    requestAnimationFrame(draw);
  }
  draw();

  // 4) Управление мышью (вертикальный drag)
  let isDragging = false;
  let startY = 0, startT = 0;

  canvas.addEventListener("mousedown", (e) => {
    isDragging = true;
    startY = e.clientY;
    startT = tParam;
  });

  canvas.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    let dy = e.clientY - startY;
    // Допустим, движением вверх увеличиваем tParam, вниз уменьшаем
    // => dy < 0 => tParam больше
    let sensitivity = 0.002; // подбери по вкусу
    let newT = startT - dy * sensitivity;
    // Ограничим [0..1]
    newT = Math.max(0, Math.min(1, newT));
    tParam = newT;
  });

  canvas.addEventListener("mouseup", () => { isDragging = false; });
  canvas.addEventListener("mouseleave", () => { isDragging = false; });

  // При изменении размеров окна
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });
</script>
</body>
</html>
